use std::default::Default;
use std::hash::Hash;
use slotmap::{new_key_type, SlotMap};
use cushy::figures::units::Px;
use cushy::styles::{Color, CornerRadii, Dimension, Edges};
use cushy::styles::components::{CornerRadius, IntrinsicPadding, TextColor, WidgetBackground};
use cushy::reactive::value::{Destination, Dynamic, Source, Switchable};
use cushy::widget::{IntoWidgetList, MakeWidget, WidgetInstance, WidgetList};
use cushy::widgets::grid::Orientation;
use cushy::widgets::{Expand, Space, Stack, Switcher};
use cushy::widgets::button::{ButtonActiveBackground, ButtonActiveForeground, ButtonBackground, ButtonForeground, ButtonHoverForeground};
use cushy::widgets::label::Displayable;
use cushy::widgets::select::SelectedColor;
use crate::context::Context;

pub trait Tab {
    fn label(&self, context: &Dynamic<Context>) -> String;
    fn make_content(&self, context: &Dynamic<Context>, tab_key: TabKey) -> WidgetInstance;
}

struct TabState<TK> {
    tab: TK,
    widget: Dynamic<WidgetInstance>,
    label: Dynamic<String>,
    on_close: Box<dyn 'static + Send + Fn()>,
}

// Needs `Clone` so that the `on_click` close button handler can access all the state.
#[derive(Clone)]
pub struct TabBar<TK>
{
    /// holds the actual tab instances and activation state which includes the tab's content widget instance
    tabs: Dynamic<SlotMap<TabKey, TabState<TK>>>,
    /// tab bar buttons
    tab_buttons: Dynamic<WidgetList>,
    /// maintains an orders list of TabKeys, used when removing tabs from `tab_items` property.
    tab_button_keys: Dynamic<Vec<TabKey>>,
    /// the active tab's content area switcher instance
    content_switcher: Dynamic<WidgetInstance>,
    /// the active tab's key, `None` when there are no tabs.
    active: Dynamic<Option<TabKey>>,
    /// tracks the most recently used tab, used when closing a tab.
    history: Dynamic<Vec<TabKey>>,
}

new_key_type! {
    pub struct TabKey;
}

impl<TK: Tab + Send + Clone + 'static> TabBar<TK> {
    pub fn new() -> Self {
        let tabs: Dynamic<SlotMap<TabKey, TabState<TK>>> = Dynamic::default();
        let active: Dynamic<Option<TabKey>> = Dynamic::new(None);
        let switcher = active.clone().switcher({
            let tabs = tabs.clone();
            move |tab_key, _|{
                match tab_key {
                    None => {
                        println!("switcher changed, no tabs");
                        Space::clear().make_widget()
                    }
                    Some(tab_key) => {
                        println!("switcher changed, tab_key: {:?}", tab_key);
                        let tabs = tabs.lock();
                        let state = tabs.get(*tab_key).unwrap();

                        state.widget.get()
                    }
                }
            }
        });


        Self {
            tabs,
            tab_buttons: Dynamic::new(WidgetList::new()),
            tab_button_keys: Dynamic::new(Vec::new()),
            content_switcher: Dynamic::new(switcher.make_widget()),
            active,
            history: Dynamic::new(Vec::new()),
        }
    }

    pub fn replace(&mut self, tab_key: TabKey, context: &Dynamic<Context>, tab: TK) {
        let mut tabs = self.tabs.lock();
        let tab_state = tabs.get_mut(tab_key).unwrap();

        let tab_content_widget = tab.make_content(context, tab_key).make_widget();
        let tab_label = tab.label(context);

        tab_state.tab = tab;
        tab_state.widget.set(tab_content_widget);
        tab_state.label.set(tab_label);

        // prevent deadlock in the switcher closure
        drop(tabs);

        match self.active.get() {
            Some(active_tab_key) if active_tab_key.eq(&tab_key) => {
                // the tab key is still the same, so it is required to remove and set the active tab
                // to force the switcher to update the content area.
                // importantly, this doesn't break the tab ordering or tab history.
                self.active.take();
                self.active.set(Some(tab_key));
            }
            _ => (),
        }
    }

    pub fn add_tab<F>(&mut self, context: &Dynamic<Context>, tab: TK, on_close: F) -> TabKey
    where
        F: 'static + Send + Fn(),
    {

        let tab_key = self.tabs.lock().insert_with_key(|tab_key| {
            let tab_label = tab.label(context);

            let tab_content = tab.make_content(context, tab_key);

            let on_close_handler = Box::new(on_close);

            let tab_state = TabState {
                tab,
                label: Dynamic::new(tab_label),
                widget: Dynamic::new(tab_content),
                on_close: on_close_handler,
            };

            tab_state
        });

        println!("tab_key: {:?}", tab_key);

        let tabs = self.tabs.lock();
        let tab_state = tabs.get(tab_key).unwrap();

        let close_button = "X".into_button()
            .on_click({
                let tab_bar = Dynamic::new(self.clone());
                move |_event|{
                    tab_bar.lock().close_tab(tab_key);
                }
            })
            .with(&ButtonForeground, Color::LIGHTGRAY)
            .with(&ButtonBackground, Color::CLEAR_BLACK)
            .with(&ButtonActiveBackground, Color::CLEAR_BLACK)
            .with(&ButtonActiveForeground, Color::RED)
            .with(&ButtonHoverForeground, Color::RED);

        let select_content = tab_state.label.clone()
            .into_label()
            .and(close_button)
            .into_columns()
            .gutter(Px::new(5))
            .pad_by(Edges::default().with_horizontal(Px::new(3)).with_top(Px::new(3)).with_bottom(Px::new(0)))
            .and(
                Space::default()
                    .height(Px::new(3))
                    .with(&WidgetBackground, self.active.map_each(move |active|{
                        let mut color = Color::CLEAR_BLACK;
                        if let Some(active) = active {
                            if active.eq(&tab_key) {
                                color = Color::SKYBLUE
                            }
                        }
                        color
                    }))
            )
            .into_rows()
            .gutter(Px::new(0));

        let select = self.active
            .new_select(Some(tab_key), select_content )
            // NOTE any less than 3 here breaks the keyboard focus for the select button, 0 = not visible, < 3 = too small
            .with(&IntrinsicPadding, Px::new(3))
            .with(&ButtonForeground, Color::LIGHTGRAY)
            .with(&ButtonHoverForeground, Color::WHITE)
            .with(&ButtonActiveBackground, Color::GRAY)
            .with(&SelectedColor, Color::GRAY)
            // TODO remove this workaround for the select button's background inheritance
            .with(&WidgetBackground, Color::CLEAR_BLACK);

        self.tab_buttons.lock().push(select);
        self.tab_button_keys.lock().push(tab_key);

        self.history.lock().push(tab_key);

        // manually drop the guard before activation
        drop(tabs);

        self.activate(tab_key);

        tab_key
    }

    pub fn close_all(&mut self) {
        self.active.set(None);
        self.tab_buttons.lock().clear();
        self.tab_button_keys.lock().clear();

        for (_key, tab_state) in self.tabs.lock().drain() {
            (tab_state.on_close)();
        }
        self.history.lock().clear();
    }

    pub fn close_tab(&mut self, tab_key: TabKey) {

        if let Some(tab_state) = self.tabs.lock().get(tab_key) {
            (tab_state.on_close)();
        }

        println!("closing tab. tab_key: {:?}", tab_key);

        let mut history = self.history.lock();
        println!("history (before): {:?}", history);
        history.retain(|&other_key| other_key != tab_key);
        history.dedup();
        let recent = history.pop();
        println!("history (after): {:?}, recent: {:?}", history, recent);
        // drop the history guard now so we don't deadlock in other methods we call that use history
        drop(history);

        if let Some(recent_key) = recent {
            self.activate(recent_key);
        } else {
            let _previously_active = self.active.take();
        }

        let mut tab_items_keys = self.tab_button_keys.lock();
        let tab_key_index = tab_items_keys.iter().enumerate().find_map(|(i, key)| {
            if *key == tab_key {
                Some(i)
            } else {
                None
            }
        }).unwrap();

        println!("tab_key_index: {:?}", tab_key_index);

        let widgets = self.tab_buttons
            .take();
        let new_widgets = WidgetList::from_iter(
            widgets
                .iter()
                .zip(tab_items_keys.iter())
                .filter_map(|( widget, index_tab_key)|{
                    println!("index_tab_key: {:?}", index_tab_key);
                    if index_tab_key.eq(&tab_key) {
                        println!("removing");
                        None
                    } else {
                        Some(widget.clone())
                    }
                })
        );
        tab_items_keys.remove(tab_key_index);

        self.tab_buttons.replace(new_widgets);

        let _ = self.tabs.lock().remove(tab_key).expect(format!("should be able to remove tab. key: {:?}", tab_key).as_str());
    }

    pub fn make_widget(&self) -> WidgetInstance {

        println!("TabBar::make_widget");

        let callback = self.active.for_each({
            let history = self.history.clone();

            move |selected_tab_key|{

                println!("key: {:?}", selected_tab_key);

                if let Some(tab_key) = selected_tab_key {
                    let mut history = history.lock();
                    history.push(tab_key.clone());
                    history.dedup();
                    drop(history);
                }
            }
        });
        callback.persist();

        let widget = TabBarWidget {
            tab_buttons: self.tab_buttons.clone(),
            content_switcher: self.content_switcher.clone()
        };

        widget.make_widget()
    }

    pub fn with_tabs<R, F>(&self, f: F) -> R
    where
        F: Fn(TabsIter<'_, TK>) -> R
    {
        let iter = self.into_iter();
        f(iter)
    }

    pub fn activate(&self, tab_key: TabKey) {
        let _previously_active = self.active.lock().replace(tab_key);
    }
}

pub struct TabsIter<'a, TK> {
    tab_bar: &'a TabBar<TK>,
    keys: Vec<TabKey>,
    index: usize,
}

impl<'a, TK> TabsIter<'a, TK> {
    pub fn new(tab_bar: &'a TabBar<TK>) -> Self {
        let keys = tab_bar.tabs.lock().keys().collect();

        Self {
            tab_bar,
            keys,
            index: 0,
        }
    }
}

impl<'a, TK: Clone> Iterator for TabsIter<'a, TK> {
    type Item = (TabKey, TK);

    fn next(&mut self) -> Option<Self::Item> {
        if self.index < self.keys.len() {
            let key = self.keys[self.index];

            let binding = self.tab_bar.tabs.lock();
            let value = binding
                .get(key)
                .map(|tab_state | (key, tab_state.tab.clone()) );

            self.index += 1;

            value

        } else {
            None
        }
    }
}

impl<'a, TK: Clone> IntoIterator for &'a TabBar<TK> {
    type Item = (TabKey, TK);
    type IntoIter = TabsIter<'a, TK>;

    fn into_iter(self) -> Self::IntoIter {
        TabsIter::new(
            self
        )
    }
}

static VERY_DARK_GREY: Color = Color::new(0x32, 0x32, 0x32, 255);

// Intermediate widget, with only the things it needs, so that it's possible to call `make_widget` which consumes self.
struct TabBarWidget {
    tab_buttons: Dynamic<WidgetList>,
    content_switcher: Dynamic<WidgetInstance>,
}

impl MakeWidget for TabBarWidget {
    fn make_widget(self) -> WidgetInstance {

        let tab_bar = [
            Stack::new(Orientation::Column, self.tab_buttons)
                .make_widget(),
            Expand::empty()
                // FIXME this causes the tab bar to take the entire height of the area under the toolbar unless a height is specified
                //       but we don't want to specify a height in pixels, we want the height to be be automatic
                //       like it is when the background color is not specified.
                .with(&WidgetBackground, VERY_DARK_GREY)
                // FIXME remove this, see above.
                .height(Px::new(38))
                .make_widget(),
        ]
            .into_columns()
            .with(&WidgetBackground, VERY_DARK_GREY)
            .with(&TextColor, Color::GRAY);

        tab_bar
            .and(self.content_switcher.expand())
            .into_rows()
            .with(&CornerRadius, CornerRadii::from(Dimension::Px(Px::new(0))))
            .make_widget()
    }
}